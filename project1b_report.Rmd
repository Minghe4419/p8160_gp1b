---
title: "Project1(B) Report"
date: "`r Sys.Date()`"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Project 1: Multivariate Non-Normal Distributions and Correlated Data

### Distributions and correlation

- We intend to generate longitudinal data.

- Target correlation structure is AR(1) or exchangeable correlation.

### Data generation method

```{r}
set.seed(123)  # for reproducibility

# Define sizes and parameters
n     <- 200    # number of subjects
t     <- 4      # number of repeated measurements per subject
beta0 <- -1.0   # intercept on logit scale
beta1 <-  0.3   # effect of time on logit scale
sigma <-  1.0   # std dev of random intercept (b_i)

# Create a data frame with one row per subject-time combination
# We'll store each subject's random intercept in 'b_i'.
dat <- data.frame(
  id   = rep(1:n, each = t),
  time = rep(1:t,     times = n)
)

# Simulate one random intercept per subject
# Then replicate that intercept across all time points for that subject.
b_i <- rnorm(n, mean = 0, sd = sigma)
dat$b_i <- b_i[dat$id]   # match the random intercept to each row

# Compute probability p_ij = logistic(beta0 + beta1*time_j + b_i)
# Then draw Y_ij ~ Bernoulli(p_ij).
dat$p_ij <- plogis(beta0 + beta1 * dat$time + dat$b_i)
dat$Y    <- rbinom(n * t, size = 1, prob = dat$p_ij)

head(dat)
```

```{r}
library(dplyr)
library(tidyr)
library(ggplot2)

#    Simply show the binary response Y.
ggplot(dat, aes(x = factor(Y))) +
  geom_bar(width = 0.4, fill = "steelblue") +
  xlab("Outcome Y (0 or 1)") +
  ylab("Count") +
  ggtitle("Distribution of Binary Outcome (Non-Normal)")

# each row becomes a subject
dat_wide <- dat %>%
  select(id, time, Y) %>%
  pivot_wider(names_from = time,
              values_from = Y,
              names_prefix = "Y_")

# Now dat_wide has columns: id, Y_1, Y_2, ... up to Y_t
pairwise_corr <- cor(dat_wide[, -1]) 
pairwise_corr
#> This matrix shows the sample correlation among times 1..t,

# which clearly prove that outcomes are not independent
pairs(
  dat_wide[, -1] + matrix(runif(nrow(dat_wide)*(ncol(dat_wide)-1), 0, 0.1),
                          nrow(dat_wide), ncol(dat_wide)-1),
  main = "Pairs Plot (Jittered) of Y_t across times"
)



```


### Simulation study 1

```{r}
# ----------------------------
# 2) Fit a naive logistic regression
# ----------------------------
library(tidyverse)
library(ggplot2)
# generate data function
generate_correlated_data <- function(n = 200, t = 4, beta0 = -1.0, beta1 = 0.3, 
                                    sigma = 1.0, family = "binomial") {

  dat <- data.frame(
    id   = rep(1:n, each = t),
    time = rep(1:t, times = n)
  )
  
  b_i <- rnorm(n, 0, sigma)
  dat$b_i <- b_i[dat$id]
  
  eta <- beta0 + beta1 * dat$time + dat$b_i
  

  if (family == "binomial") {
    dat$p_ij <- plogis(eta)
    dat$Y    <- rbinom(n * t, size = 1, prob = dat$p_ij)
  } 
  # adding continue in the future
  
  return(dat)
}
```

```{r}
run_simulation_simple <- function(n_sim = 1000, n = 200, t = 4, 
                                  beta0 = -1.0, beta1 = 0.3, sigma = 1.0) {
  results <- data.frame(
    beta_est = numeric(n_sim),
    se       = numeric(n_sim),
    p_value  = numeric(n_sim),
    coverage = logical(n_sim)
  )
  
  for (i in 1:n_sim) {
    dat <- generate_correlated_data(n, t, beta0, beta1, sigma)
    

    fit_wrong <- glm(Y ~ time, data = dat, family = binomial)
    summ <- summary(fit_wrong)
    ci <- suppressMessages(confint.default(fit_wrong))
    
    results[i, ] <- c(
      coef(fit_wrong)["time"],
      summ$coefficients["time", "Std. Error"],
      summ$coefficients["time", "Pr(>|z|)"],
      (ci["time", 1] < beta1) & (ci["time", 2] > beta1)
    )
  }
  
  return(results)
}

```

```{r}
# （sigma=1.0）
set.seed(123)
sim_results <- run_simulation_simple(n_sim = 1000, sigma = 1.0)


metrics <- data.frame(
  bias         = mean(sim_results$beta_est - 0.3),
  coverage     = mean(sim_results$coverage),
  type_I_error = mean(sim_results$p_value < 0.05) # 当beta1=0时使用
)
print(metrics)


ggplot(sim_results, aes(x = beta_est)) +
  geom_histogram(bins = 30, fill = "skyblue", alpha = 0.7) +
  geom_vline(xintercept = 0.3, color = "red", linetype = "dashed") +
  labs(title = "Distribution of Beta1 Estimates", 
       x = "Estimated Beta1", y = "Count")

cat(sprintf("Coverage rate: %.3f (95%% CI: %.3f - %.3f)",
            metrics$coverage,
            metrics$coverage - 1.96*sqrt(metrics$coverage*(1-metrics$coverage)/1000),
            metrics$coverage + 1.96*sqrt(metrics$coverage*(1-metrics$coverage)/1000)))
```









```

### Simulation study 2

```{r}
# install.packages("geepack")
library(geepack)

gee_fit <- geeglm(Y ~ time, 
                  family = binomial, 
                  id = id, 
                  corstr = "exchangeable",
                  data = dat)
summary(gee_fit)

```

